import sys
import asyncio
from os import path
from tomllib import load, loads
from kivy.resources import resource_add_path

from kivy.app import App
from kivy.config import Config
from kivy.core.window import Window

from view import View
from presenter import Presenter
from helpers.dataclasses import TomlConfig
from helpers.async_wrapper import sync_to_async_wrapper
from helpers.constants import WINDOW_SIZE, ICON_PATH, WINDOW_TITLE, TOML_PATH, TOML_CONTENT


class MainApp(App):
    """Main app class"""

    toml_config: TomlConfig = TomlConfig(**loads(TOML_CONTENT))
    _empty_toml_config: TomlConfig = TomlConfig(**loads(TOML_CONTENT))

    def __init__(self, **kwargs) -> None:
        super().__init__(**kwargs)

        if path.exists(TOML_PATH):
            with open(TOML_PATH, "rb") as f:
                self.toml_config = TomlConfig(**load(f))
        else:
            with open(TOML_PATH, "w") as f:
                f.write(TOML_CONTENT)

        self.presenter = Presenter(self.toml_config)

        Config.set('input', 'mouse', 'mouse,multitouch_on_demand')
        Config.set('kivy', 'exit_on_escape', '0')

        Window.size = WINDOW_SIZE
        Window.bind(on_resize=lambda *_: Window._set_size(WINDOW_SIZE))  # Static window size

    @sync_to_async_wrapper
    async def on_start(self) -> None:
        if self.toml_config is None or self.toml_config == self._empty_toml_config:
            await self.presenter.view.show_popup(
                "Config Info",
                "[b]Please exit and fill in the config.toml file generated by the app.[/b]",
                "yellow",
                btn_callback=self.stop,
                btn_text="Exit"
            )

    def build(self) -> View:
        self.icon = ICON_PATH
        self.title = WINDOW_TITLE
        return self.presenter.view


if __name__ == '__main__':
    # Add the resource path for the kivy app
    if hasattr(sys, '_MEIPASS'):
        resource_add_path(path.join(sys._MEIPASS))

    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop)

    app = MainApp()

    try:
        loop.run_until_complete(app.async_run())
    except KeyboardInterrupt:
        while True:
            try:
                app.stop()
                break
            except KeyboardInterrupt:
                pass

    loop.close()
